;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Definitions for the Appotech AX206 CPU
;
; This file was generated by dclib/netpp. Modifications to this file
; will be lost.
;
; Stylesheet: asm8051.xsl       (c) 2010-2011 section5
;
; Version: 0.1develop
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Address segment 'SFR'
;
; SFR registers from 0x80-0xff
;
		
; Port 0 I/O
p0                   = 0x80
    _P07             = (0x80+7) 
    _P06             = (0x80+6) 
    _P05             = (0x80+5) 
    _P04             = (0x80+4) 
    _P03             = (0x80+3) 
    _P02             = (0x80+2) 
    _P01             = (0x80+1) 
    _P00             = (0x80+0) 
  P07          = (1 << 7)
  P06          = (1 << 6)
  P05          = (1 << 5)
  P04          = (1 << 4)
  P03          = (1 << 3)
  P02          = (1 << 2)
  P01          = (1 << 1)
  P00          = (1 << 0)


; The stack pointer
sp                   = 0x81


; Data Pointer Control
dpcon                = 0x86
  IA           = (1 << 7)     ; IRQ vector base address: 0: 0x0000, 1: 0x1000
  DPIDO        = (1 << 6)     ; Auto mode: 0: INC, 1: DEC
  DPAID        = (1 << 4)     ; Automatic DPTR (in/de)crement enable bit


; Power Control
pcon                 = 0x87
  STOPC        = (1 << 7)
  SELRTC       = (1 << 6)
  OSCCEN       = (1 << 5)
  TMRCSEL      = (1 << 3)     ; 0: 24 MHz; 1: 12 MHz; 2: 48 MHz; 3: 48 MHz
  USBCEN       = (1 << 2)
  SLEEP        = (1 << 1)
  COREEN       = (1 << 0)


; Port 1 I/O
p1                   = 0x90
    _P17             = (0x90+7) 
    _P16             = (0x90+6) 
    _P15             = (0x90+5) 
    _P14             = (0x90+4) 
    _P13             = (0x90+3) 
    _P12             = (0x90+2) 
    _P11             = (0x90+1) 
    _P10             = (0x90+0) 
  P17          = (1 << 7)
  P16          = (1 << 6)
  P15          = (1 << 5)
  P14          = (1 << 4)
  P13          = (1 << 3)
  P12          = (1 << 2)
  P11          = (1 << 1)
  P10          = (1 << 0)


; Multiplier Result 0
mulres0              = 0x91


; Multiplier Result 1
mulres1              = 0x92


; Multiplier Result 2
mulres2              = 0x93


; Multiplier Result 3
mulres3              = 0x94


; Multiplier Control
mulcon               = 0x98
    _MULR2           = (0x98+5) 
    _MULR1           = (0x98+4) 
    _MULR0           = (0x98+3) 
    _MULSH           = (0x98+0) 
  MULR2        = (1 << 5)     ; Round Bit 2 After Shift
  MULR1        = (1 << 4)     ; Round Bit 1 After Shift
  MULR0        = (1 << 3)     ; Round Bit 0 After Shift
  MULSH        = (1 << 0)     ; Arithmetic shift after Multiply


; Port Wakeup Pending
wkpnd                = 0x9a
  WPDP         = (1 << 3)     ; USBDP Wakeup pending bit (1: pending)
  WPP07        = (1 << 2)     ; P0.7 Wakeup pending bit (1: pending)
  WPP06        = (1 << 1)     ; P0.6 Wakeup pending bit (1: pending)
  WPP05        = (1 << 0)     ; P0.5 Wakeup pending bit (1: pending)


; Port Wakeup Enable Register
wken                 = 0x9b
  WEDP         = (1 << 3)     ; USB Wakeup Disable(1)
  WEP07        = (1 << 2)     ; P0.7 Wakeup Disable(1)
  WEP06        = (1 << 1)     ; P0.6 Wakeup Disable(1)
  WEP05        = (1 << 0)     ; P0.5 Wakeup Disable(1)


; Wakeup Edge, 0: Rising, 1: Falling. See wken register
wkedg                = 0x9c


; Port 2 I/O
p2                   = 0xa0
    _P27             = (0xa0+7) 
    _P26             = (0xa0+6) 
    _P25             = (0xa0+5) 
    _P24             = (0xa0+4) 
    _P23             = (0xa0+3) 
    _P22             = (0xa0+2) 
    _P21             = (0xa0+1) 
    _P20             = (0xa0+0) 
  P27          = (1 << 7)
  P26          = (1 << 6)
  P25          = (1 << 5)
  P24          = (1 << 4)
  P23          = (1 << 3)
  P22          = (1 << 2)
  P21          = (1 << 1)
  P20          = (1 << 0)


; Port Input Enable
pie                  = 0xa4


; Clock Control
ckcon                = 0xa5
  IROMCEN      = (1 << 0)     ; IROM clock enable


; IRQ enable
ie                   = 0xa8
    _EA              = (0xa8+7) 
    _RAWIE           = (0xa8+6) 
    _WAUIE           = (0xa8+5) 
    _SPIIE           = (0xa8+4) 
    _USBIE           = (0xa8+3) 
    _T2IE            = (0xa8+2) 
    _T1IE            = (0xa8+1) 
    _T0IE            = (0xa8+0) 
  EA           = (1 << 7)     ; Global IRQ enable
  RAWIE        = (1 << 6)     ; Reset and watchdog IRQ enable
  WAUIE        = (1 << 5)     ; Port/UART IRQ enable
  SPIIE        = (1 << 4)     ; SPI interrupt enable
  USBIE        = (1 << 3)     ; USB interrupt enable
  T2IE         = (1 << 2)     ; Timer2 IRQ enable
  T1IE         = (1 << 1)     ; Timer1 IRQ enable
  T0IE         = (1 << 0)     ; Timer0 IRQ enable


; Port 3 I/O
p3                   = 0xb0
    _P37             = (0xb0+7) 
    _P36             = (0xb0+6) 
    _P35             = (0xb0+5) 
    _P34             = (0xb0+4) 
    _P33             = (0xb0+3) 
    _P32             = (0xb0+2) 
    _P31             = (0xb0+1) 
    _P30             = (0xb0+0) 
  P37          = (1 << 7)
  P36          = (1 << 6)
  P35          = (1 << 5)
  P34          = (1 << 4)
  P33          = (1 << 3)
  P32          = (1 << 2)
  P31          = (1 << 1)
  P30          = (1 << 0)


; Timer0 Control
tmr0con              = 0xb1
  T0PND        = (1 << 7)     ; Timer pending
  T0OS         = (1 << 3)     ; External clock select; 0: P2.1, 1: RTC
  T0CS         = (1 << 2)     ; Clock mode; 0: Sysclk, 1: ext
  T0SE         = (1 << 1)     ; Clock edge; 0: rising, 1: falling
  T0ON         = (1 << 0)     ; Timer enable


; Timer0 Counter
tmr0cnt              = 0xb3


; Timer0 Period
tmr0pr               = 0xb4


; Timer0 Prescaler
tmr0psr              = 0xb5
  T0PSR        = (1 << 0)


; Interrupt Priority
ip                   = 0xb8
    _WDTIE           = (0xb8+7) 
    _RAWIP           = (0xb8+6) 
    _WAUIP           = (0xb8+5) 
    _SPIIP           = (0xb8+4) 
    _USBIP           = (0xb8+3) 
    _T2IP            = (0xb8+2) 
    _T1IP            = (0xb8+1) 
    _T0IP            = (0xb8+0) 
  WDTIE        = (1 << 7)     ; Watchdog overflow mode
  RAWIP        = (1 << 6)     ; RTC and Watchdog
  WAUIP        = (1 << 5)     ; Port/UART
  SPIIP        = (1 << 4)     ; SPI
  USBIP        = (1 << 3)     ; USB
  T2IP         = (1 << 2)     ; Timer 2 IRQ
  T1IP         = (1 << 1)     ; Timer 1 IRQ
  T0IP         = (1 << 0)     ; Timer 0 IRQ


; Watchdog Control
wdtcon               = 0xbb
  WDTTO        = (1 << 7)     ; Watchdog Timeout; 1: Timeout
  WDTPD        = (1 << 6)     ; CPU sleep bit; 1: CPU slept
  WDTPND       = (1 << 5)     ; WDOG Timer busy; R: 1: busy, W: 1: clear busy
  WDTEN        = (1 << 4)     ; WDOG Timer enable
  WDTPSR       = (1 << 0)     ; WDOG Timer Postscaler


; Bit Fetcher Counter
bfcnt                = 0xbc
  BFCNT        = (1 << 0)


; Bit Fetcher Buffer low
bfbuf0               = 0xbd


; Bit Fetcher Buffer Mid
bfbuf1               = 0xbe


; Bit Fetcher Buffer high
bfbuf2               = 0xbf


; Port 3 I/O
p4                   = 0xc0
    _P42             = (0xc0+2) 
    _P41             = (0xc0+1) 
    _P40             = (0xc0+0) 
  P42          = (1 << 2)
  P41          = (1 << 1)
  P40          = (1 << 0)


; Timer2 Control
tmr2con              = 0xc1
  T2POS2       = (1 << 7)     ; PWM Out P4.1 Select
  T2POS1       = (1 << 6)     ; PWM Out P2.6 Select
  T2S          = (1 << 5)     ; Clock Source Select; 0: Sysclk, 1: RTC
  T2POEN       = (1 << 4)     ; PWM out enable
  T2PSR        = (1 << 1)     ; Prescaler
  T2ON         = (1 << 0)     ; Timer enable


; Timer2 Counter low
tmr2cntl             = 0xc2


; Timer2 Counter high
tmr2cnth             = 0xc3


; Timer2 Period low
tmr2perl             = 0xc4


; Timer2 Period high
tmr2perh             = 0xc5


; Timer2 PWM Duty Cycle low
tmr2pwml             = 0xc6


; Timer2 PWM Duty Cycle high
tmr2pwmh             = 0xc7


; USB Control
usbcon               = 0xc8
    _SOFPND          = (0xc8+7) 
    _USBDONE         = (0xc8+6) 
    _USBRST          = (0xc8+5) 
    _PHYEN           = (0xc8+4) 
    _DPPU            = (0xc8+3) 
    _USBRNW          = (0xc8+2) 
    _USBKS           = (0xc8+0) 
  SOFPND       = (1 << 7)     ; R: 1: pending, W: 0: clear SOF pending
  USBDONE      = (1 << 6)     ; R/W done (1)
  USBRST       = (1 << 5)     ; 1: Reset
  PHYEN        = (1 << 4)     ; Phy Enable (1)
  DPPU         = (1 << 3)     ; DPU PU select (1)
  USBRNW       = (1 << 2)     ; USB operation select; 0: Write, 1: Read
  USBKS        = (1 << 0)     ; 1: initiate USB transaction (kick start)


; USB Data I/O
usbdata              = 0xc9


; USB Address
usbadr               = 0xca


; Multiplier Operand X low
mulxl                = 0xcb


; Multiplier Operand X high
mulxh                = 0xcc


; Multiplier Operand Y low
mulyl                = 0xcd


; Multiplier Operand Y high
mulyh                = 0xce


; Program Status
psw                  = 0xd0


; RTC Counter
rtcnt                = 0xd1


; ADC Control
adccon               = 0xd2
  ADCGO        = (1 << 7)     ; RD: Conversion finished (0), WR: Start Conversion (1)
  EOC          = (1 << 6)     ; End of conversion
  ADCCHOP      = (1 << 5)     ; ADC offset chopper enable
  VREFSEL      = (1 << 4)     ; VRef select O: AVDD; 1: P1.0
  ADCEN        = (1 << 3)     ; ADC enable
  ADCSEL       = (1 << 0)     ; ADC input select


; ADC Baudrate control
adcrate              = 0xd3
  TMREN        = (1 << 7)     ; Timer Input Enable
  ADCTS        = (1 << 6)     ; Timer Source
  ADCRATE      = (1 << 0)     ; ADC conversion rate


; ADC buffer high
adcbufh              = 0xd4


; SPI clock rate register
spirate              = 0xd6


; SPI data I/O register
spibuf               = 0xd7


; SPI control register
spicon               = 0xd8
    _SPIPND          = (0xd8+7) 
    _SPISM           = (0xd8+6) 
    _SPIRT           = (0xd8+5) 
    _SPIWS           = (0xd8+4) 
    _SPIEDGE         = (0xd8+2) 
    _SPIIDST         = (0xd8+1) 
    _SPIEN           = (0xd8+0) 
  SPIPND       = (1 << 7)     ; SPI transaction: 0: busy; 1: completed
  SPISM        = (1 << 6)     ; 0: Master, 1: Slave
  SPIRT        = (1 << 5)     ; 2 wire mode: 0: TX, 1: RX
  SPIWS        = (1 << 4)     ; SPI mode: 0: 3-wire, 1: 2-wire
  SPIEDGE      = (1 << 2)     ; Sample edge: 0: F, 1: R (SPIIDST=0), 0: R, 1: F (SPIIDST=1)
  SPIIDST      = (1 << 1)     ; SPI idle: 0: low, 1: high
  SPIEN        = (1 << 0)     ; SPI enable


; ADC buffer low
adcbufl              = 0xdc


; Timer2 Control
tmr1con              = 0xe1
  T1POS2       = (1 << 7)     ; PWM Out P4.0 Select
  T1POS1       = (1 << 6)     ; PWM Out P2.3 Select
  T1S          = (1 << 4)     ; Clock mode; 0: Sysclk, 1: EXT rising, 2: EXT falling, 3: RTC
  T1OD         = (1 << 2)     ; PWM Open Drain Output
  T1POEN       = (1 << 1)     ; PWM Output Enable
  T1ON         = (1 << 0)     ; Timer Enable


; Timer1 Counter low
tmr1cntl             = 0xe2


; Timer1 Counter high
tmr1cnth             = 0xe3


; Timer1 Period low
tmr1perl             = 0xe4


; Timer1 Period high
tmr1perh             = 0xe5


; Timer1 PWM Duty Cycle low
tmr1pwml             = 0xe6


; Timer1 PWM Duty Cycle high
tmr1pwmh             = 0xe7


eif0                 = 0xe8
    _DIM             = (0xe8+4) 
    _DIP             = (0xe8+3) 
    _T2P             = (0xe8+2) 
    _T1P             = (0xe8+1) 
    _T0P             = (0xe8+0) 
  DIM          = (1 << 4)     ; USB DM (D-) input
  DIP          = (1 << 3)     ; USB DP (D+) input
  T2P          = (1 << 2)     ; Timer2; R: 1: pending; W: 0: clear
  T1P          = (1 << 1)     ; Timer1; R: 1: pending; W: 0: clear
  T0P          = (1 << 0)     ; Timer0; R: 1: pending; W: 0: clear


; P0 Port direction (1: Input)
p0dir                = 0xe9


; P1 Port direction (1: Input)
p1dir                = 0xea


; P2 Port direction (1: Input)
p2dir                = 0xeb


; P3 Port direction (1: Input)
p3dir                = 0xec


; P4 Port direction (1: Input)
p4dir                = 0xed


; UART Status
uartsta              = 0xf1
  DONE         = (1 << 7)     ; TX done
  FER          = (1 << 6)     ; Frame Error Flag
  RXDONE       = (1 << 5)     ; RX has completed
  TXDONE       = (1 << 4)     ; TX has completed
  USRC         = (1 << 0)     ; I/O select; 0: TX=P2.7, RX=P2.5; 1: TX=P4.1, RX=P4.0


; UART Control
uartcon              = 0xf2
  UTSBS        = (1 << 7)     ; 0: 1 stop bit, 1: 2 stop bits
  UTTXNB       = (1 << 6)     ; 9 Bit value
  NBITEN       = (1 << 5)     ; 9 Bit mode (1)
  UTEN         = (1 << 4)     ; UART enable
  UTTXINV      = (1 << 3)     ; TX invert (1)
  UTRXINV      = (1 << 2)     ; RX invert (1)
  TXIE         = (1 << 1)     ; TX IRQ Enable (1)
  RXIE         = (1 << 0)     ; RX IRQ Enable (1)


; UART Baudrate
uartbaud             = 0xf3


tmr3con              = 0xf8
    _BOREN           = (0xf8+7) 
    _BOROEN          = (0xf8+6) 
    _BGOEN           = (0xf8+5) 
    _T3FB            = (0xf8+4) 
    _T3CP            = (0xf8+3) 
    _T3IE            = (0xf8+2) 
    _T3LP            = (0xf8+1) 
    _T3ON            = (0xf8+0) 
  BOREN        = (1 << 7)     ; BOR Enable
  BOROEN       = (1 << 6)     ; BOR Output Enable
  BGOEN        = (1 << 5)     ; Bandgap Output Enable
  T3FB         = (1 << 4)     ; RTC Feedback Resistor Enable
  T3CP         = (1 << 3)     ; Clear RTC Pending
  T3IE         = (1 << 2)     ; RTC IRQ Enable
  T3LP         = (1 << 1)     ; Low Power Mode Enable
  T3ON         = (1 << 0)     ; RTC enable


; Port0 Pull-up; 1: enable Pullup
p0up                 = 0xf9


; Port1 Pull-up; 1: enable Pullup
p1up                 = 0xfa


; Port2 Pull-up; 1: enable Pullup
p2up                 = 0xfb


; Port3 Pull-up; 1: enable Pullup
p3up                 = 0xfc


; Port4 Pull-up; 1: enable Pullup
p4up                 = 0xfd



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Address segment 'USB'
;
; The indirect USB controller registers
;
		
FAddr                = 0x00
  UPDATE       = (1 << 7)
  ADDR         = (1 << 0)

Power                = 0x01
  RESET        = (1 << 3)
  RESUME       = (1 << 2)
  SUSPEND      = (1 << 1)
  EN_SUSP      = (1 << 0)

IntrIn1              = 0x02
  EP2          = (1 << 2)
  EP1          = (1 << 1)
  EP0          = (1 << 0)

IntrOut1             = 0x04
  EP2          = (1 << 2)
  EP1          = (1 << 1)

IntrUSB              = 0x06
  ISOF         = (1 << 3)
  IRST         = (1 << 2)
  IRESM        = (1 << 1)
  ISUSP        = (1 << 0)

; See bitfields in IntrIn1
IntrIn1E             = 0x07

; See bitfields in IntrOut1
IntrOut1E            = 0x09

; See bitfields in IntrUSB
IntrUSBE             = 0x0b

Frame1               = 0x0c

Frame2               = 0x0d

Index                = 0x0e

FIFO0                = 0x20

FIFO1                = 0x21


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Address segment 'USBIndexed'
;
; USB indexed registers
;
		
InMaxP               = 0x10

CSR0                 = 0x11
  E0_SSUEND    = (1 << 7)     ; SetupEnd service. Write 1 to clear.
  E0_SOPRDY    = (1 << 6)     ; Out packet serviced. Write 1 to clear.
  E0_SDSTL     = (1 << 5)     ; Send stall. Write 1 to terminate current tx.
  E0_SUEND     = (1 << 4)     ; Setup end. Generates IRQ, W1C
  E0_DATAEND   = (1 << 3)     ; Data end. Autocleared.
  E0_STSTL     = (1 << 2)     ; 1: Got stall handshake. Clear manually.
  E0_INPRDY    = (1 << 1)     ; Set bit when TX packet ready.
  E0_OPRDY     = (1 << 0)     ; 1 if RX packet ready. Clears when E0_SOPRDY is set.

InCSR1               = 0x11
  INCLRDT      = (1 << 6)     ; Write 1 to clear EP IN data toggle
  INSTSTL      = (1 << 5)     ; 1: Got stall. W0C.
  INSDSTL      = (1 << 4)     ; 1: Send stall. Clear manually after.
  INFLUSH      = (1 << 3)     ; Flush 1 pkt from IN FIFO
  INUNDRUN     = (1 << 2)     ; FIFO underrun
  INFIFONE     = (1 << 1)     ; At least 1 pkt in FIFO
  INPRDY       = (1 << 0)     ; In Pkt ready. Autocleared, generates IRQ.

InCSR2               = 0x12
  AUTOSET      = (1 << 7)     ; 1: INPRDY automatically set when pkt in FIFO
  ISO          = (1 << 6)     ; 1: Isochronous EP1 mode
  MODE         = (1 << 5)     ; Endpoint direction; 1: IN, 0: OUT
  INDMAEN      = (1 << 4)     ; 1: Enable DMA for IN
  FORCEDTOG    = (1 << 3)     ; 1: Force IN data toggle

OutMaxP              = 0x13

OutCSR1              = 0x14
  OCLRDT       = (1 << 7)     ; Write 1 to clr data toggle
  OSTSTL       = (1 << 6)     ; Got handshake STALL. W0C.
  OSDSTL       = (1 << 5)     ; Send STALL. Clear after.
  OFLUSH       = (1 << 4)     ; Flush 1 pkt from OUT FIFO
  ODATERR      = (1 << 3)     ; Data error in ISO mode
  OOVRUN       = (1 << 2)     ; Overrun, ISO mode only. W0C.
  OFIFOFUL     = (1 << 1)     ; FIFO full
  OPRDY        = (1 << 0)     ; Out pkt ready. W0C when done.

OutCSR2              = 0x15
  ISO          = (1 << 6)     ; 1: Isochronous mode for OUT EP
  ODMAEN       = (1 << 5)     ; Enable DMA for OUT EP
  DMAMOD       = (1 << 4)     ; DMA mode. See HW reference

Count0               = 0x16

OutCount1            = 0x16

OutCount2            = 0x17

