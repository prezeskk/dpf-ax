The SDCC development environment for AX206 based DPFs
----------------------------------------------------------------------------

This README covers a few details about the development on the AX206
8051 clone. Since there are so many variants and designs of DPFs out there,
it can be quite a pain to get the software running right.
Also, it is very easy to brick a DPF and make it unusable.

BIG DISCLAIMER: The Author(s) take(s) no resposibility for what you do with
this information. If you brick your DPF, it's all YOUR fault.

Files
-------

Makefile     : Here you find how all is built
bootstrap.lnk: The linker file. Specifies how code is distributed into
              banks (see 'Bank Switching' below)
compile.py   : Puts stuff together into a flash image

*.h          : Some header files are generated by the netpp library.
               If you have modifications to make to these files, notify
               the author.

Bank switching
------------------

Since we have only a few kB for code, we need to swap stuff in from the
SPI flash. This is achieved using bank switching. A special construct
from sdcc calls a loader instead of jumping directly into the actual
routine. This implies a 'bank number', which is merely an extension of the
16 bit address. For further encoding of code segments, group bitfields are
used. Basically, the linker puts all the code into one big 24 bit linear
address space according to the layout described in the *.lnk file, then
compile.py squeezes it all into a loadable hex image.

Functions declared in the C code with __banked are swapped in by the
bankswitch.s handler.

This opens a few nasty potential traps:
- Local object instances such as strings don't live anymore after the
  bank has been switched. So you will get garbage output.
- Calling a non-banked function from another module will result in
  unexpected behaviour, normally crashes / reboots. Thus: Declare all your
  non-banked functions static! (Unless they're living in a common code area)

Bank scheme:
The MSB of a relocation address (see *.lnk file) contains the bank number
code which consists of a bank index and a group number.
A rudimentary mechanism is implemented to prevent accidental overlaps of
switched banks. This uses a group number with the following simple rule:

	Only banks with the same group number may overlap.

It is thus possible to swap out code in various areas. Those have to be
specified manually in the LNK file.

Coding details
---------------

The watchdog: You might find a RUB_WATCHDOG() macro in various main loops.
This is necessary to keep the watch dog happy, otherwise it will bark and
the system will reset and reboot. This is a hint for faulty code or hanging
poll loops. The reset interval is determined by the WDTPSR bitfield in the
wdtcon register.

Auto increment
---------------

The default for the autoincrement is OFF. C code depends on that.
Hopefully we'll figure out some kind of support in SDCC for it, for the
time being you should only use the autoinc feature within assembler code and
reset the state at the end of the routine.

Data sections
--------------

Here is a draft of a memory map of the AX206. The internal SRAM is
mirrored into various places, currently, the following memory segments
were identified:
         
__code     __xdata     __idata

0x1bff     0x01ff                     ----------
   |          |                         SCRATCH
0x1b00     0x0100                     ----------
0x1aff                   0xff         ----------
   |                       |            DAT/USB  (*)
0x1a00                   0x00         ----------
0x19ff     0x11ff                     ----------
   |          |                         SRAM
0x1000     0x0800                     ----------
0x0fff                                ----------
   |                                     ROM
0x0000                                ----------

(*) Possibly, only 2*(8 + 64) bytes are used for the USB controller FIFO
The memory from 0x90-0x100 can obviously be used as scratch pad.

__code: This is the code memory area, basically readonly (movc access)

__xdata: External data memory, shared with __code (movx access)
	If you use __xdata pointers, you will have to sort out specific
	data areas where no code can live. Also, this data is a priori
	not initialized by the bank loader.
__idata: Also not initialized by the bank loader. All initializations
         are in the GSINIT segment.

I/O
--------------

Timer0: Generic timer
Timer1: PWM for Backlight LED
Timer2: Possibly used for sound output (not present on most DPFs)
Timer3: RTC

See pinout in dpf.h
Note that the buttons may be swapped on some DPFs.

Flash memory layout
---------------------

Important:

Currently, if you change the offsets in the flash, make sure that you
fix them in various places:

Typically:
0x180000	New firmware jump table
0x190000	Character table
0x1f0000	Copy of original firmware's jump table, patched

utils.inc:
    jumptable_offset = 0x180088
bootstrap.lnk:
    -g _chartbl_offs = 0x190000
jmptbl.s:
    Module offsets
